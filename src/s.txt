// src/design-tool/components/CanvasEditor.jsx
import React, { useEffect, useRef, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import * as fabric from 'fabric';
import StraightText from '../objectAdders/straightText';
import CircleText from '../objectAdders/CircleText';
import updateObject from '../functions/update';
import { store } from '../redux/store';
import { setCanvasObjects } from '../redux/canvasSlice';
import { FabricImage } from 'fabric';
import updateExisting from '../utils/updateExisting';
import FloatingMenu from './FloatingMenu';
import { handleCanvasAction } from '../utils/canvasActions';
import ShapeAdder from '../objectAdders/Shapes';

// --- HELPERS ---
const uuidv4 = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

// ... (Keep extractFontsFromJSON and other helpers unchanged) ...

export default function CanvasEditor({
  setActiveTool,
  setSelectedId,
  setFabricCanvas,
  fabricCanvas,
  printDimensions,
  productId,
  activeView,
}) {
  const canvasRef = useRef(null);
  const fabricCanvasRef = useRef(null);
  const isSyncingRef = useRef(false);
  const [initialized, setInitialized] = useState(false);
  const wrapperRef = useRef(null);
  const canvasObjects = useSelector((state) => state.canvas.present);
  const previousStatesRef = useRef(new Map());
  const dispatch = useDispatch();

  const [menuPosition, setMenuPosition] = useState(null);
  const [selectedObjectLocked, setSelectedObjectLocked] = useState(false);
  const [selectedObjectUUIDs, setSelectedObjectUUIDs] = useState([]);
  const shapes = ['rect', 'circle', 'triangle', 'star', 'pentagon', 'hexagon', 'line', 'arrow', 'diamond', 'trapezoid', 'heart', 'lightning', 'bubble'];

  // âœ… NEW: Touch/Gesture State
  const gestureState = useRef({
     lastScale: 1,
     isGesture: false,
     startDistance: 0
  });

  // âœ… 1. SMART FIT FUNCTION (Replaces the old hardcoded scaling)
  const fitDesignToScreen = (canvas, containerWidth, containerHeight) => {
    if (!canvas || !printDimensions.width) return;

    const padding = containerWidth < 768 ? 20 : 60; // Less padding on mobile
    const availWidth = containerWidth - padding;
    const availHeight = containerHeight - padding;

    // Calculate Zoom to fit the Print Area into the Container
    const scaleX = availWidth / printDimensions.width;
    const scaleY = availHeight / printDimensions.height;
    const zoom = Math.min(scaleX, scaleY);

    // Center the content
    const centerX = (containerWidth - printDimensions.width * zoom) / 2;
    const centerY = (containerHeight - printDimensions.height * zoom) / 2;

    // Apply Transform: [scaleX, skewY, skewX, scaleY, translateX, translateY]
    canvas.setViewportTransform([zoom, 0, 0, zoom, centerX, centerY]);
    
    // Update Control Handles size based on zoom (Inverse scaling)
    // This makes sure handles remain touchable even if zoom is small
    const controlSize = containerWidth < 768 ? 24 : 12; // Big handles on mobile
    fabric.Object.prototype.set({
        cornerSize: controlSize / zoom, 
        transparentCorners: false,
        cornerColor: '#ffffff',
        cornerStrokeColor: '#333333',
        borderColor: '#4f46e5',
        borderScaleFactor: 2 / zoom, // Thicker borders when zoomed out
        touchCornerSize: 40 / zoom, // Hit area for touch
    });
    
    canvas.requestRenderAll();
  };

  const updateMenuPosition = () => {
    const canvas = fabricCanvasRef.current;
    if (!canvas) return;

    const activeObj = canvas.getActiveObject();

    if (activeObj) {
      // âœ… Fix Menu Position accounting for Viewport Transform (Zoom/Pan)
      const vpt = canvas.getViewportTransform();
      const objectCenter = activeObj.getCenterPoint();
      
      // Transform canvas coordinates to screen coordinates
      const screenX = objectCenter.x * vpt[0] + vpt[4];
      const screenY = objectCenter.y * vpt[3] + vpt[5];
      const scaledHeight = activeObj.getScaledHeight() * vpt[3];

      setMenuPosition({
        left: screenX,
        top: screenY - (scaledHeight / 2) - 50 // Offset for menu above object
      });

      // ... (Rest of existing logic)
      if (activeObj.type === 'activeselection' || activeObj.type === 'group') {
        const ids = activeObj.getObjects().map(o => o.customId);
        setSelectedObjectUUIDs(ids);
        setSelectedObjectLocked(activeObj.getObjects().some(o => o.lockMovementX));
      } else {
        setSelectedObjectUUIDs([activeObj.customId]);
        setSelectedObjectLocked(activeObj.lockMovementX === true);
      }
    } else {
      setMenuPosition(null);
      setSelectedObjectUUIDs([]);
    }
  };

  // âœ… 2. INITIALIZE CANVAS & LISTENERS
  useEffect(() => {
    let canvas = fabricCanvasRef.current;
    if (!canvas) {
      canvas = new fabric.Canvas(canvasRef.current, {
        backgroundColor: '#f3f4f6', // Light gray bg to see canvas bounds
        selection: true,
        controlsAboveOverlay: true,
        preserveObjectStacking: true,
      });
      fabricCanvasRef.current = canvas;
      setFabricCanvas(canvas);
      setInitialized(true);
      
      // âœ… Enable Touch Gestures (Simple Pinch/Pan implementation)
      canvas.on('mouse:wheel', function(opt) {
          if (opt.e.ctrlKey) { // Zoom
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 5) zoom = 5;
            if (zoom < 0.05) zoom = 0.05;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
          } else { // Pan
            // Optional: Implement panning on scroll or leave default
          }
      });
    }

    const resizeCanvas = () => {
      if (wrapperRef.current && canvas) {
        const { clientWidth, clientHeight } = wrapperRef.current;
        canvas.setDimensions({ width: clientWidth, height: clientHeight });
        // Use our smart fit function
        fitDesignToScreen(canvas, clientWidth, clientHeight);
      }
    };

    const ro = new ResizeObserver(() => resizeCanvas());
    if (wrapperRef.current) ro.observe(wrapperRef.current);

    resizeCanvas();
    return () => { ro.disconnect(); };
  }, [printDimensions]); // Re-run when print dimensions change

  // âœ… 3. HANDLE BORDER & CLIP PATH
  useEffect(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !printDimensions.width) return;
    
    // Remove old borders
    canvas.getObjects().forEach((obj) => {
      if (obj.customId === 'print-area-border' || obj.id === 'print-area-border') {
        canvas.remove(obj);
      }
    });
    
    // Create Clip Path (The Print Area)
    const printAreaRect = new fabric.Rect({
        left: 0,
        top: 0,
        width: printDimensions.width,
        height: printDimensions.height,
        absolutePositioned: true,
    });
    
    // Set Clip Path
    canvas.clipPath = printAreaRect;
    
    // Visual Border (Dashed line)
    const visualBorder = new fabric.Rect({
        left: 0,
        top: 0,
        width: printDimensions.width,
        height: printDimensions.height,
        fill: '#ffffff', // White background for the print area
        stroke: 'rgba(0,0,0,0.2)',
        strokeWidth: 4, // Thicker stroke
        strokeDashArray: [10, 10],
        selectable: false,
        evented: false,
        customId: 'print-area-border',
        id: 'print-area-border'
    });
    
    canvas.add(visualBorder);
    canvas.sendToBack(visualBorder); // Ensure it's behind objects
    canvas.requestRenderAll();
    
    // Refit screen just in case
    if (wrapperRef.current) {
       fitDesignToScreen(canvas, wrapperRef.current.clientWidth, wrapperRef.current.clientHeight);
    }

  }, [printDimensions, activeView]);

  // âœ… 4. SMART FOCUS (THE "NOBODY DID IT" FEATURE)
  useEffect(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas) return;

    const handleSelection = (e) => {
      if (isSyncingRef.current) return;
      
      const selected = e.selected?.[0];
      if (selected) {
        setSelectedId(selected.customId);
        setActiveTool(selected.textEffect === 'circle' ? 'circle-text' : selected.type);
        updateMenuPosition();

        // ðŸ”¥ SMART FOCUS: On Mobile, Zoom to the object
        if (window.innerWidth < 768) {
           const objCenter = selected.getCenterPoint();
           const zoomLevel = canvas.getZoom() * 1.5; // Zoom in 50% more than current
           
           // Animate Viewport to center the object
           canvas.animate({
                viewportTransform: [zoomLevel, 0, 0, zoomLevel, 
                    (canvas.width / 2) - (objCenter.x * zoomLevel), 
                    (canvas.height / 2) - (objCenter.y * zoomLevel)
                ]
           }, {
               duration: 400,
               onChange: canvas.renderAll.bind(canvas),
               easing: fabric.util.ease.easeOutExpo
           });
        }
      }
    };

    const handleCleared = () => {
      if (isSyncingRef.current) return;
      setSelectedId(null);
      setActiveTool(null);
      setMenuPosition(null);

      // ðŸ”¥ SMART RESTORE: Zoom back out when deselected
      if (window.innerWidth < 768 && wrapperRef.current) {
          fitDesignToScreen(canvas, wrapperRef.current.clientWidth, wrapperRef.current.clientHeight);
      }
    };

    const handleMoving = () => {
      if (isSyncingRef.current) return;
      updateMenuPosition();
    };

    canvas.on('selection:created', handleSelection);
    canvas.on('selection:updated', handleSelection);
    canvas.on('selection:cleared', handleCleared);
    canvas.on('object:moving', handleMoving);
    canvas.on('object:scaling', handleMoving);
    canvas.on('object:rotating', handleMoving);
    canvas.on('object:modified', handleMoving);

    return () => {
      canvas.off('selection:created', handleSelection);
      // ... (off other events)
    };
  }, [fabricCanvas, setSelectedId, setActiveTool]);

  // ... (Keep step 5 and 6: handle modifications and sync redux unchanged) ...
  // Ensure 'updateMenuPosition' calls inside them use the new function defined above.
  
  // (Paste Step 5 & 6 here from your original file, no logic change needed there)
  // ...

  return (
    <div ref={wrapperRef} id="canvas-wrapper" className="relative w-full h-full overflow-hidden bg-slate-100">
      <canvas ref={canvasRef} id="canvas" />

      {menuPosition && selectedObjectUUIDs.length > 0 && (
        <FloatingMenu
          position={menuPosition}
          onAction={(action) => handleCanvasAction(action, selectedObjectUUIDs, store.getState().canvas.present, dispatch, setCanvasObjects)}
          isLocked={selectedObjectLocked}
        />
      )}
    </div>
  );
}